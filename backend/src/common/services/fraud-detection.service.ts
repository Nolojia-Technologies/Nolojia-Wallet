import { Injectable, Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Transaction } from '../../database/entities/transaction.entity';\nimport { User } from '../../database/entities/user.entity';\nimport { AuditLogService, AuditAction, AuditSeverity } from './audit-log.service';\n\nexport interface FraudCheckResult {\n  isHighRisk: boolean;\n  riskScore: number;\n  riskFactors: string[];\n  recommendedAction: 'ALLOW' | 'REVIEW' | 'BLOCK';\n  blockedReason?: string;\n}\n\nexport interface TransactionContext {\n  userId: string;\n  amount: number;\n  paymentMethod: string;\n  ipAddress: string;\n  userAgent: string;\n  phoneNumber?: string;\n}\n\n@Injectable()\nexport class FraudDetectionService {\n  private readonly logger = new Logger(FraudDetectionService.name);\n\n  // Risk thresholds\n  private readonly HIGH_RISK_THRESHOLD = 70;\n  private readonly BLOCK_THRESHOLD = 85;\n  private readonly LARGE_AMOUNT_THRESHOLD = 100000; // KES 100K\n  private readonly VELOCITY_THRESHOLD = 5; // transactions per hour\n  private readonly MAX_FAILED_ATTEMPTS = 3;\n\n  constructor(\n    @InjectRepository(Transaction)\n    private transactionRepository: Repository<Transaction>,\n    @InjectRepository(User)\n    private userRepository: Repository<User>,\n    private auditLogService: AuditLogService,\n  ) {}\n\n  async checkTransactionFraud(context: TransactionContext): Promise<FraudCheckResult> {\n    this.logger.log(`Running fraud check for user ${context.userId}, amount: ${context.amount}`);\n\n    const riskFactors: string[] = [];\n    let riskScore = 0;\n\n    // 1. Amount-based risk assessment\n    const amountRisk = await this.assessAmountRisk(context.amount, context.userId);\n    riskScore += amountRisk.score;\n    riskFactors.push(...amountRisk.factors);\n\n    // 2. Velocity-based risk assessment\n    const velocityRisk = await this.assessVelocityRisk(context.userId);\n    riskScore += velocityRisk.score;\n    riskFactors.push(...velocityRisk.factors);\n\n    // 3. User behavior risk assessment\n    const behaviorRisk = await this.assessUserBehaviorRisk(context);\n    riskScore += behaviorRisk.score;\n    riskFactors.push(...behaviorRisk.factors);\n\n    // 4. Device/IP risk assessment\n    const deviceRisk = await this.assessDeviceRisk(context.userId, context.ipAddress, context.userAgent);\n    riskScore += deviceRisk.score;\n    riskFactors.push(...deviceRisk.factors);\n\n    // 5. Payment method risk assessment\n    const paymentRisk = await this.assessPaymentMethodRisk(context.paymentMethod, context.userId);\n    riskScore += paymentRisk.score;\n    riskFactors.push(...paymentRisk.factors);\n\n    // 6. Time-based risk assessment\n    const timeRisk = this.assessTimeRisk();\n    riskScore += timeRisk.score;\n    riskFactors.push(...timeRisk.factors);\n\n    // Determine final recommendation\n    const isHighRisk = riskScore >= this.HIGH_RISK_THRESHOLD;\n    let recommendedAction: 'ALLOW' | 'REVIEW' | 'BLOCK' = 'ALLOW';\n    let blockedReason: string | undefined;\n\n    if (riskScore >= this.BLOCK_THRESHOLD) {\n      recommendedAction = 'BLOCK';\n      blockedReason = `High fraud risk score: ${riskScore}. Factors: ${riskFactors.join(', ')}`;\n    } else if (isHighRisk) {\n      recommendedAction = 'REVIEW';\n    }\n\n    // Log the fraud check\n    if (isHighRisk) {\n      await this.auditLogService.logSuspiciousActivity(\n        `Fraud check flagged transaction: Risk score ${riskScore}`,\n        context.userId,\n        context.ipAddress,\n        {\n          riskScore,\n          riskFactors,\n          amount: context.amount,\n          paymentMethod: context.paymentMethod,\n        },\n      );\n    }\n\n    return {\n      isHighRisk,\n      riskScore,\n      riskFactors: riskFactors.filter(factor => factor), // Remove empty factors\n      recommendedAction,\n      blockedReason,\n    };\n  }\n\n  private async assessAmountRisk(amount: number, userId: string): Promise<{ score: number; factors: string[] }> {\n    const factors: string[] = [];\n    let score = 0;\n\n    // Check if amount is unusually large\n    if (amount > this.LARGE_AMOUNT_THRESHOLD) {\n      score += 25;\n      factors.push(`Large transaction amount: KES ${amount.toLocaleString()}`);\n    }\n\n    // Check user's historical transaction amounts\n    const userAvgAmount = await this.getUserAverageTransactionAmount(userId);\n    if (userAvgAmount > 0 && amount > userAvgAmount * 5) {\n      score += 20;\n      factors.push(`Amount significantly higher than user average`);\n    }\n\n    // Check for suspicious round numbers\n    if (this.isSuspiciousRoundNumber(amount)) {\n      score += 10;\n      factors.push(`Suspicious round number pattern`);\n    }\n\n    return { score, factors };\n  }\n\n  private async assessVelocityRisk(userId: string): Promise<{ score: number; factors: string[] }> {\n    const factors: string[] = [];\n    let score = 0;\n\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n    const recentTransactions = await this.transactionRepository.count({\n      where: {\n        senderId: userId,\n        createdAt: new Date(oneHourAgo.getTime()),\n        status: 'PENDING' as any,\n      },\n    });\n\n    if (recentTransactions >= this.VELOCITY_THRESHOLD) {\n      score += 30;\n      factors.push(`High transaction velocity: ${recentTransactions} transactions in the last hour`);\n    }\n\n    // Check for failed attempts\n    const failedAttempts = await this.transactionRepository.count({\n      where: {\n        senderId: userId,\n        createdAt: new Date(oneHourAgo.getTime()),\n        status: 'FAILED' as any,\n      },\n    });\n\n    if (failedAttempts >= this.MAX_FAILED_ATTEMPTS) {\n      score += 25;\n      factors.push(`Multiple failed attempts: ${failedAttempts} in the last hour`);\n    }\n\n    return { score, factors };\n  }\n\n  private async assessUserBehaviorRisk(context: TransactionContext): Promise<{ score: number; factors: string[] }> {\n    const factors: string[] = [];\n    let score = 0;\n\n    // Check user account age\n    const user = await this.userRepository.findOne({ where: { id: context.userId } });\n    if (user) {\n      const accountAgeMs = Date.now() - user.createdAt.getTime();\n      const accountAgeDays = accountAgeMs / (1000 * 60 * 60 * 24);\n\n      if (accountAgeDays < 1) {\n        score += 30;\n        factors.push('Very new account (less than 1 day old)');\n      } else if (accountAgeDays < 7) {\n        score += 15;\n        factors.push('New account (less than 1 week old)');\n      }\n\n      // Check if user has completed KYC\n      if (!user.isKycVerified) {\n        score += 20;\n        factors.push('User KYC not verified');\n      }\n    }\n\n    // Check if this is user's first transaction\n    const userTransactionCount = await this.transactionRepository.count({\n      where: { senderId: context.userId },\n    });\n\n    if (userTransactionCount === 0) {\n      score += 15;\n      factors.push('First transaction for user');\n    }\n\n    return { score, factors };\n  }\n\n  private async assessDeviceRisk(\n    userId: string,\n    ipAddress: string,\n    userAgent: string,\n  ): Promise<{ score: number; factors: string[] }> {\n    const factors: string[] = [];\n    let score = 0;\n\n    // Check for suspicious user agents\n    if (this.isSuspiciousUserAgent(userAgent)) {\n      score += 20;\n      factors.push('Suspicious user agent detected');\n    }\n\n    // Check for IP address patterns\n    if (this.isSuspiciousIP(ipAddress)) {\n      score += 25;\n      factors.push('Suspicious IP address pattern');\n    }\n\n    // Check if user is accessing from multiple IPs recently\n    const recentIPs = await this.getRecentUserIPs(userId);\n    if (recentIPs.length > 3) {\n      score += 15;\n      factors.push(`Multiple IP addresses used recently: ${recentIPs.length}`);\n    }\n\n    return { score, factors };\n  }\n\n  private async assessPaymentMethodRisk(\n    paymentMethod: string,\n    userId: string,\n  ): Promise<{ score: number; factors: string[] }> {\n    const factors: string[] = [];\n    let score = 0;\n\n    // Check if user has used this payment method before\n    const previousUse = await this.transactionRepository.count({\n      where: {\n        senderId: userId,\n        paymentMethod,\n        status: 'COMPLETED' as any,\n      },\n    });\n\n    if (previousUse === 0) {\n      score += 10;\n      factors.push('First time using this payment method');\n    }\n\n    // Method-specific risk assessment\n    switch (paymentMethod) {\n      case 'crypto':\n        score += 15;\n        factors.push('Cryptocurrency payment method (higher risk)');\n        break;\n      case 'card':\n        score += 5;\n        factors.push('Card payment method');\n        break;\n      case 'mpesa':\n        // M-Pesa is generally lower risk in Kenya\n        break;\n      case 'bank':\n        // Bank transfers are generally lower risk\n        break;\n    }\n\n    return { score, factors };\n  }\n\n  private assessTimeRisk(): { score: number; factors: string[] } {\n    const factors: string[] = [];\n    let score = 0;\n\n    const now = new Date();\n    const hour = now.getHours();\n\n    // Check for unusual hours (late night/early morning)\n    if (hour >= 0 && hour <= 5) {\n      score += 10;\n      factors.push('Transaction attempted during unusual hours (midnight to 5 AM)');\n    }\n\n    // Check for weekends (potentially higher risk)\n    const dayOfWeek = now.getDay();\n    if (dayOfWeek === 0 || dayOfWeek === 6) {\n      score += 5;\n      factors.push('Weekend transaction');\n    }\n\n    return { score, factors };\n  }\n\n  private async getUserAverageTransactionAmount(userId: string): Promise<number> {\n    const result = await this.transactionRepository\n      .createQueryBuilder('transaction')\n      .select('AVG(transaction.amount)', 'average')\n      .where('transaction.senderId = :userId', { userId })\n      .andWhere('transaction.status = :status', { status: 'COMPLETED' })\n      .andWhere('transaction.type = :type', { type: 'DEPOSIT' })\n      .getRawOne();\n\n    return parseFloat(result.average) || 0;\n  }\n\n  private isSuspiciousRoundNumber(amount: number): boolean {\n    // Check for very round numbers\n    const amountStr = amount.toString();\n    \n    // Amounts ending in many zeros\n    if (amount >= 10000 && amount % 10000 === 0) {\n      return true;\n    }\n\n    // Repeated digits\n    if (/([0-9])\\1{3,}/.test(amountStr)) {\n      return true;\n    }\n\n    // Sequential numbers\n    if (this.hasSequentialDigits(amountStr)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private hasSequentialDigits(str: string): boolean {\n    for (let i = 0; i < str.length - 2; i++) {\n      const a = parseInt(str[i]);\n      const b = parseInt(str[i + 1]);\n      const c = parseInt(str[i + 2]);\n\n      if (b === a + 1 && c === b + 1) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private isSuspiciousUserAgent(userAgent: string): boolean {\n    const suspiciousPatterns = [\n      /bot/i,\n      /crawler/i,\n      /spider/i,\n      /curl/i,\n      /wget/i,\n      /python-requests/i,\n      /postman/i,\n      /insomnia/i,\n    ];\n\n    return suspiciousPatterns.some(pattern => pattern.test(userAgent));\n  }\n\n  private isSuspiciousIP(ipAddress: string): boolean {\n    // Check for localhost/private IPs in production\n    if (process.env.NODE_ENV === 'production') {\n      const privateIPPatterns = [\n        /^127\\./,\n        /^10\\./,\n        /^172\\.(1[6-9]|2[0-9]|3[01])\\./,\n        /^192\\.168\\./,\n        /^::1$/,\n        /^localhost$/i,\n      ];\n\n      if (privateIPPatterns.some(pattern => pattern.test(ipAddress))) {\n        return true;\n      }\n    }\n\n    // Check for known VPN/proxy IP ranges (simplified)\n    // In production, this would use a more comprehensive IP reputation service\n    const vpnPatterns = [\n      /^185\\./,  // Common VPN range\n      /^45\\./,   // Common VPN range\n    ];\n\n    return vpnPatterns.some(pattern => pattern.test(ipAddress));\n  }\n\n  private async getRecentUserIPs(userId: string): Promise<string[]> {\n    // This would typically query audit logs or session data\n    // For now, return a simplified result\n    const recent = await this.transactionRepository\n      .createQueryBuilder('transaction')\n      .select('DISTINCT transaction.metadata', 'metadata')\n      .where('transaction.senderId = :userId', { userId })\n      .andWhere('transaction.createdAt >= :since', { since: new Date(Date.now() - 24 * 60 * 60 * 1000) })\n      .getRawMany();\n\n    // Extract IP addresses from metadata (if stored)\n    return recent\n      .map(r => r.metadata?.ipAddress)\n      .filter(ip => ip)\n      .slice(0, 10); // Limit to last 10 unique IPs\n  }\n\n  // Method to update fraud rules based on patterns\n  async updateFraudRules(newRules: any): Promise<void> {\n    // In production, this would update configurable fraud rules\n    // For now, log the update\n    this.logger.log('Fraud rules updated', newRules);\n  }\n\n  // Method to whitelist/blacklist users\n  async updateUserRiskProfile(userId: string, riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'BLOCKED'): Promise<void> {\n    // In production, this would update user risk profiles in the database\n    this.logger.log(`User ${userId} risk profile updated to ${riskLevel}`);\n  }\n}"